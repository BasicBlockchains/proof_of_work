# An Object Oriented proof of work Blockchain

---


    GUI
     |
     | - Api;
     | - Node
          |
          | - Wallet
          | - Miner
          | - Blockchain
                | 
                | - Database
                | - Block
                     |
                     | - MiningTransaction
                     |      |
                     |      | - UTXO_OUTPUT
                     |
                     | - Transaction
                            |
                            | - UTXO_OUTPUT
                            | - UTXO_INPUT


---
## Encryption

The BB-POW uses elliptic curve cryptography (ECC), employing the custom package we have written. [Pypi package](https://pypi.org/project/basicblockchains-ecc/)


We use the standard secp256k1 elliptic curve for cryptographic purposes. 
This curve will be used to generate the public key from a private key, as well as for digital signatures.
All signatures will follow the elliptic curve digital signature algorithm (ECDSA), wherein the private key can create a signature and the public key can be used to validate the signature.
Note that the private key will be an integer of roughly 256 bit length, and the public key will be a pair of integers of similar bit length.
This public key represents a point on the elliptic curve and so we refer to these integers as the x- and y-coordinates.
We follow convention by compressing the public key according to the parity of the y coordinate; where we use *0x02* to indicate even and *0x03* to indicate odd, and refer to this as the compressed public key (cpk).
Both the private key and public key will be expressed as integers, but the compressed public key will be expressed as a hexadecimal (hex) string **with** the leading '0x'.

In addition to the elliptic curve encryption, we use the SHA256 hash function to generate ids for all the objects in the blockchain.
Additionally, SHA256 along with SHA1 will be used in order to create a user address.

## Wallet
The Wallet class contains the private and public keys used in the ECC. Each wallet can be represented by a seed value, which will be a randomly generated 256-bit integer.
This will be saved as a hex string in plaintext to the user's harddrive. 


The Wallet class contains the private and public keys used in the blockchain.
We use the private key in the ECDSA; given a transaction id string, a unique signature can be generated by the wallet using the private key.
Note that the ECDSA contains randomness, so two signatures for the same transaction (tx) id  may be completely different, but both still valid.
From the ECDSA, we see that we can use the public key in order to verify a signature, without having to reveal the private key.
Thus, in this fashion, we fix our signature for a given tx id to be the compressed public key along with the pair of integers generated by the ECDSA from the private key.


### Address and BASE58 Encoding

The create_address algorithm is as follows:

    -Take the SHA1 of the SHA256 of the compressed public key (with leading 0x in the hex string). This yields the encoded public key (EPK)
    -We ensure that the EPK is 40 characters - WILL NOT CONTAIN A LEADING "0x"
    -We take the first 8 characters of the SHA256 of the SHA256 of the EPK. This is the checksum
    -We append the checksum to the EPK to create the checksum encoded public key (CEPK). THIS IS A HEX STRING OF 48 CHARACTERS WITHOUT THE LEADING "0x"
    -The address is the BASE58 encoding of the 48-character CEPK hex string

## Transactions and UTXOs

We follow Bitcoin in adopting the UTXO model for recording financial transactions.

The blockchain produces new currency through mining (see below). 
In short, every new block which is saved to the blockchain will contain a unique MiningTransaction.
This MiningTransaction is how new coins are added to the Blockchain.

Each MiningTransaction will contain an unspent transaction output (UTXO), for which the class is called UTXO_OUTPUT.
Each output will contain an integer value, a wallet address, as well as an optional block_height value.
This output indicates that the user with that address is the current owner of the amount of coins in the utxo; the block_height means that the utxo can't be used in any transaction until the chain has reached that height.

Additionally, each MiningTransaction will contain some periphery information about the state of the chain when the block was mined.

For peer-to-peer (P2P) transactions, we have the Transaction class, which accepts a list of UTXO_OUTPUTs as well as a list of UTXO_INPUTs as well.
The UTXO_INPUT class will contain a tx id and an index value, which uniquely identify a UTXO_OUTPUT; and the input will contain a signature for the UTXO_OUTPUT.
The signature contains the compressed public key, which will be used to identity the address of the UTXO_OUTPUT. 
As well, the signature contains the ECDSA signature tuple, which, along with the compressed public key and tx_id, is used to validate the signature.

When a Transaction gets saved to the blockchain, the UTXO_OUTPUTS referred to by the UTXO_INPUT will get removed from the Node database; we refer to this as "consuming" the utxos.

## Block

A Block is the class which is saved to the Blockchain. It will contain some header information, packaged in the Header class, as well as a MiningTransaction and a list of Transactions.


### Merkle root

## Blockchain

### Target

### Database

We use SQLite3 as our database. This has a type limitation as their integers are signed and only store (-2^63+1,
2^63-1). Thus all integers saved to the db will be given as hex strings with a prepended '0x'.

I would like to thank Jurko Gospodnetic of stackoverflow for his db query design.
-https://stackoverflow.com/questions/9561832/what-if-i-dont-close-the-database-connection-in-python-sqlite


## Mining